Imports System.ComponentModel
Imports System.IO

Public Class Form1

    Private ReadOnly _templatePart0 As XCData = <![CDATA[
' Licensed to the .NET Foundation under one or more agreements.
' The .NET Foundation licenses this file to you under the MIT license.
' See the LICENSE file in the project root for more information.

Imports System.IO
Imports System.Reflection
Imports System.Threading
Imports CSharpToVBApp
Imports CSharpToVBConverter
Imports CSharpToVBConverter.ConversionResult

Imports Microsoft.CodeAnalysis
Imports Microsoft.CodeAnalysis.Emit

Imports Xunit

Namespace ConvertDirectory.Tests

    ''' <summary>
    ''' Return False to skip test
    ''' </summary>
    <TestClass()> Public Class TestCompile
        Private _lastFileProcessed As String

        Public Shared ReadOnly Property EnableRoslynTests() As Boolean
            Get
                Return Directory.Exists(GetRoslynRootDirectory)
            End Get
        End Property

        Private Async Function TestProcessDirectoryAsync(SourceDirectory As String) As Task(Of Boolean)
            Return Await ProcessDirectoryAsync(MainForm:=Nothing, SourceDirectory, TargetDirectory:="", StopButton:=Nothing, ListBoxFileList:=Nothing, SourceLanguageExtension:="cs", New ProcessingStats(""), AddressOf Me.TestProcessFileAsync, CancellationToken.None).ConfigureAwait(continueOnCapturedContext:=True)
        End Function

        Friend Function TestProcessFileAsync(MainForm As Form1, PathWithFileName As String, TargetDirectory As String, _0 As String, CSPreprocessorSymbols As List(Of String), VBPreprocessorSymbols As List(Of KeyValuePair(Of String, Object)), OptionalReferences() As MetadataReference, SkipAutoGenerated As Boolean, CancelToken As CancellationToken) As Task(Of Boolean)
            ' Save to TargetDirectory not supported
            Assert.True(String.IsNullOrWhiteSpace(TargetDirectory))
            ' Do not delete the next line or the parameter it is needed by other versions of this routine
            _lastFileProcessed = PathWithFileName
            Using fs As FileStream = File.OpenRead(PathWithFileName)
                Dim RequestToConvert As ConvertRequest = New ConvertRequest(mSkipAutoGenerated:=True, mProgress:=Nothing, mCancelToken:=CancelToken) With {
                    .SourceCode = fs.GetFileTextFromStream()
                }

                Dim ResultOfConversion As ConversionResult = ConvertInputRequest(RequestToConvert, New DefaultVBOptions, CSPreprocessorSymbols, VBPreprocessorSymbols, CSharpReferences(Assembly.Load("System.Windows.Forms").Location, OptionalReferences).ToArray, ReportException:=Nothing, mProgress:=Nothing, CancelToken:=CancellationToken.None)
                If ResultOfConversion.ResultStatus = ResultTriState.Failure Then
                    Return Task.FromResult(False)
                End If
                Dim CompileResult As (CompileSuccess As Boolean, EmitResult As EmitResult) = CompileVisualBasicString(StringToBeCompiled:=ResultOfConversion.ConvertedCode, VBPreprocessorSymbols, DiagnosticSeverity.Error, ResultOfConversion)
                If Not CompileResult.CompileSuccess OrElse ResultOfConversion.GetFilteredListOfFailures().Any Then
                    Dim Msg As String = If(CompileResult.CompileSuccess, ResultOfConversion.GetFilteredListOfFailures()(0).GetMessage, "Fatal Compile error")
                    Throw New ApplicationException($"{PathWithFileName} failed to compile with error :{vbCrLf}{Msg}")
                    Return Task.FromResult(False)
                End If
            End Using
            Return Task.FromResult(True)
        End Function

        ]]>

    Private ReadOnly _templatePart1 As XCData = <![CDATA[

    End Class

End Namespace
]]>

    Private _currentBuffer As Control

    Private Property CurrentBuffer As Control
        Get
            Return _currentBuffer
        End Get
        Set(value As Control)
            _currentBuffer = value
            If value IsNot Nothing Then
                _currentBuffer.Focus()
            End If
        End Set
    End Property

    Private Shared Function XCDataToString(Optional data As XCData = Nothing) As String
        Return data?.Value.Replace(vbLf, Environment.NewLine)
    End Function

    Private Sub ContextMenuCopy_Click(sender As Object, e As EventArgs) Handles ContextMenuCopy.Click
        If TypeOf Me.ContextMenuStrip1.SourceControl Is RichTextBox Then
            CType(Me.ContextMenuStrip1.SourceControl, RichTextBox).Copy()
        Else
            If Me.ContextMenuStrip1.SourceControl IsNot Nothing Then
                Clipboard.SetText(CType(Me.ContextMenuStrip1.SourceControl, ListBox).SelectedItem.ToString)
            End If
        End If
    End Sub

    Private Sub ContextMenuCut_Click(sender As Object, e As EventArgs) Handles ContextMenuCut.Click
        If TypeOf Me.ContextMenuStrip1.SourceControl Is RichTextBox Then
            CType(Me.ContextMenuStrip1.SourceControl, RichTextBox).Cut()
        End If
    End Sub

    Private Sub ContextMenuPaste_Click(sender As Object, e As EventArgs) Handles ContextMenuPaste.Click
        Dim sourceControl As RichTextBox = CType(Me.ContextMenuStrip1.SourceControl, RichTextBox)
        If sourceControl Is Nothing Then
            Exit Sub
        End If
        If sourceControl.CanPaste(DataFormats.GetFormat(DataFormats.Rtf)) OrElse
            sourceControl.CanPaste(DataFormats.GetFormat(DataFormats.Text)) Then
            sourceControl.Paste()
        End If
    End Sub

    Private Sub ContextMenuRedo_Click(sender As Object, e As EventArgs) Handles ContextMenuRedo.Click
        Dim sourceControl As RichTextBox = CType(Me.ContextMenuStrip1.SourceControl, RichTextBox)
        If sourceControl IsNot Nothing AndAlso sourceControl.CanRedo Then
            sourceControl.Redo()
        End If
    End Sub

    Private Sub ContextMenuSelectAll_Click(sender As Object, e As EventArgs) Handles ContextMenuSelectAll.Click
        Dim sourceControl As RichTextBox = CType(Me.ContextMenuStrip1.SourceControl, RichTextBox)
        If sourceControl IsNot Nothing Then
            sourceControl.SelectAll()
        End If
    End Sub

    Private Sub ContextMenuStrip1_Opening(sender As Object, e As CancelEventArgs) Handles ContextMenuStrip1.Opening
        Dim ContextMenu As ContextMenuStrip = CType(sender, ContextMenuStrip)

        If TypeOf Me.CurrentBuffer Is RichTextBox Then
            Dim sourceBuffer As RichTextBox = CType(Me.CurrentBuffer, RichTextBox)
            ContextMenu.Items(ContextMenu.IndexOf(NameOf(ContextMenuCopy))).Enabled = sourceBuffer.TextLength > 0 And sourceBuffer.SelectedText.Any
            ContextMenu.Items(ContextMenu.IndexOf(NameOf(ContextMenuCut))).Enabled = sourceBuffer.TextLength > 0 And sourceBuffer.SelectedText.Any
            ContextMenu.Items(ContextMenu.IndexOf(NameOf(ContextMenuPaste))).Enabled = sourceBuffer.CanPaste(DataFormats.GetFormat(DataFormats.Rtf)) OrElse sourceBuffer.CanPaste(DataFormats.GetFormat(DataFormats.Text))
            ContextMenu.Items(ContextMenu.IndexOf(NameOf(ContextMenuRedo))).Enabled = sourceBuffer.CanRedo
            ContextMenu.Items(ContextMenu.IndexOf(NameOf(ContextMenuUndo))).Enabled = sourceBuffer.CanUndo
        Else
            ContextMenu.Items(ContextMenu.IndexOf(NameOf(ContextMenuCut))).Enabled = False
            ContextMenu.Items(ContextMenu.IndexOf(NameOf(ContextMenuPaste))).Enabled = False
            ContextMenu.Items(ContextMenu.IndexOf(NameOf(ContextMenuRedo))).Enabled = False
            ContextMenu.Items(ContextMenu.IndexOf(NameOf(ContextMenuUndo))).Enabled = False
        End If
    End Sub

    Private Sub ContextMenuUndo_Click(sender As Object, e As EventArgs) Handles ContextMenuUndo.Click
        Dim sourceControl As RichTextBox = CType(Me.ContextMenuStrip1.SourceControl, RichTextBox)
        If sourceControl IsNot Nothing AndAlso sourceControl.CanUndo Then
            sourceControl.Undo()
        End If
    End Sub

    Private Sub mnuFileSelectRootDirectory_Click(sender As Object, e As EventArgs) Handles mnuFileSelectRootDirectory.Click
        Dim SourceFolderName As String
        Using OFD As New FolderBrowserDialog
            With OFD
                .Description = "Select root folder..."
                .ShowNewFolderButton = False
                If .ShowDialog(Me) <> DialogResult.OK Then
                    Exit Sub
                End If
                SourceFolderName = .SelectedPath
                If Not Directory.Exists(SourceFolderName) Then
                    MsgBox($"{SourceFolderName} is not a directory.",
                       MsgBoxStyle.OkOnly Or MsgBoxStyle.Exclamation Or MsgBoxStyle.MsgBoxSetForeground,
                       Title:="Generate Test Folder List")
                    Exit Sub
                End If
                Dim DriveName As String = New DriveInfo(.SelectedPath).RootDirectory.Name
                Me.TreeView1.Nodes.Clear()
                Me.TreeView1.Nodes.Add(.SelectedPath)
                PopulateTreeView(.SelectedPath, Me.TreeView1.Nodes(0))
            End With
        End Using

    End Sub

    Private Sub TabControl1_SelectedIndexChanged(sender As Object, e As EventArgs) Handles TabControl1.SelectedIndexChanged
        Select Case Me.TabControl1.SelectedTab.Text
            Case "TreeView"
                Stop
            Case "Template"
                Stop
            Case "Result"
                Dim RTB As RichTextBox = CType(Me.TabControl1.SelectedTab.Controls(0), RichTextBox)
                RTB.Text = XCDataToString(_templatePart0)
                RTB.AppendText(XCDataToString(_templatePart1))
            Case Else
                Stop
        End Select
    End Sub

    Private Sub TreeView1_BeforeExpand(sender As Object, e As TreeViewCancelEventArgs) Handles TreeView1.BeforeExpand
        Dim MyExistNode As TreeNode = e.Node
        'Clear TreeNode
        MyExistNode.Nodes.Clear()

        Try
            'Loop For Get Folders
            Dim mypath As String = MyExistNode.FullPath

            'Loop For Get Folders
            Dim csFileList As String() = Directory.GetFiles(mypath, "*.cs")
            If csFileList.Length > 0 Then
                Exit Sub
            End If
            For Each myFolders As String In Directory.GetDirectories(mypath)
                Dim FldrNode As TreeNode = MyExistNode.Nodes.Add(Path.GetFileName(myFolders))
                'Here, Expand is use for add Expanding option "[+]" on folder
                If Directory.GetFiles(myFolders, "*.cs").Length = 0 Then
                    FldrNode.Nodes.Add("Expand")
                End If
            Next

            'Loop For Get Files

            For Each MyFiles As String In csFileList
                Dim FLNode As TreeNode = MyExistNode.Nodes.Add(Path.GetFileName(MyFiles))
            Next
        Catch ex As Exception

        End Try

    End Sub

    Public Shared Sub PopulateTreeView(directoryValue As String, parentNode As TreeNode)
        Try
            'Loop For Get Folders
            For Each myFolders As String In Directory.GetDirectories(directoryValue)
                Dim FldrNode As TreeNode = parentNode.Nodes.Add(Path.GetFileName(myFolders))
                'Here, Expand is use for add Expanding option "[+]" on folder
                FldrNode.Nodes.Add("Expand")
            Next

            'Loop For Get Files
            For Each MyFiles As String In Directory.GetFiles(directoryValue)
                Dim FLNode As TreeNode = parentNode.Nodes.Add(Path.GetFileName(MyFiles))
            Next
        Catch unauthorized As UnauthorizedAccessException
            parentNode.Nodes.Add("Access Denied")
        End Try
    End Sub

End Class
